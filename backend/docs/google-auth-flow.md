Детальный Флоу
1. Фронтенд: Пользователь нажимает кнопку "Вход через Google".

2. Фронтенд -> Бэкенд: Улетает запрос на твой бэкенд: GET /api/v1/auth/google/login.

Важно: Фронтенд должен передать в этом запросе параметр, который бэкенд использует для редиректа обратно на фронтенд с токеном. Например, frontend_redirect_uri=https://your-felend-app.com/auth-callback. Этот эндпоинт на фронтенде будет отвечать за прием и сохранение токена.

3. Бэкенд felend (/api/v1/auth/google/login):

3.1. Генерирует уникальный state параметр и сохраняет его.

3.2. Формирует полный URL для Google (с client_id, redirect_uri=https://your-backend.com/api/v1/auth/google/callback, scope=openid email profile, response_type=code, и сгенерированным state).

3.3 Бэкенд отвечает фронтенду HTTP 302 Redirect на этот Google URL.

4. Браузер пользователя: Автоматически переходит по этому Google URL.

5. Google: Пользователь видит страницу согласия Google, выбирает аккаунт, даёт разрешения.

6. Google -> Бэкенд felend: Google делает редирект на твой бэкенд redirect_uri (/api/v1/auth/google/callback) с code и state в query-параметрах.

7. Бэкенд felend (/auth/google/callback):

7.1. Проверяет state.

7.2. Обменивает code на access_token и id_token от Google.

7.3 Декодирует id_token (или использует access_token для запроса к Google UserInfo API), чтобы получить email и profile пользователя.

7.4 Аутентификация/Регистрация: 

7.4.1 Проверяет есть ли в таблице google_accounts аккаунт с таким же email, если есть, то это авторизация для пользователя, к которому привязан этот гугл аккаунт

7.4.1 Если в google_accounts емайл не нашли, то ищем в users такой email, если найден, то авторизация для пользователя которого нашли

7.4.2 Если в базе не нашлось никого с таким email, то это регистрация нового пользователя

7.5 Создаем под юзера уникальный однаразовый токен и записываем его в таблицу токенов (новая таблица) связывая с пользователем

7.6 ОТВЕЧАЕТ HTTP 302 Redirect обратно на фронтенд, используя frontend_redirect_uri, переданный на шаге 2. но теперь с созданным токеном

8. frontend на странице frontend_redirect_uri получает токен и делает с ним запрос на ендпоинт для обмена на JWT-токены

9. backend на ендпоинте обмена однаразового токена на JWT проверяет его в таблице и смотрит что он еще не был использован, если всего хорошо, то в ответ выдает фронту JWT токена на этого пользователя
